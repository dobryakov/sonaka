# Research: Личный кабинет покупателя — дашборд заказов

**Feature**: 001-customer-orders-dashboard  
**Date**: 2025-11-03  
**Status**: Complete

## Summary

Исследование технических решений для реализации личного кабинета покупателя интернет-магазина Sonaka. Рассмотрены архитектурные паттерны, выбор технологий, подходы к тестированию и реализации специфических требований.

## 1. Архитектура и разделение ответственности

### Decision: Микросервисная архитектура на контейнерах Docker

Использование Docker Compose для разделения backend, frontend и database в отдельные сервисы.

**Rationale**:
- Соответствие конституции проекта: "Контейнер‑первая архитектура"
- Изоляция сервисов упрощает независимую разработку и тестирование
- Порты > 10000 для избежания конфликтов с системными сервисами
- Конфигурация через `.env` обеспечивает гибкость деплоя

**Alternatives considered**:
- Монолитное приложение — отклонено, так как требуется SPA + REST API
- Kubernetes — отклонено на этапе разработки, избыточен для текущих требований

### Decision: REST API версионирование через пути

API endpoints структурированы как `/api/v1/...`

**Rationale**:
- Конституция требует версионированные эндпоинты
- Путевое версионирование проще понять и дебажить чем версии в заголовках
- Поддержка нескольких версий API одновременно

**Alternatives considered**:
- Версионирование через заголовки — отклонено как более сложное для клиентов

## 2. Бэкенд: Ruby on Rails API

### Decision: JSON serializers (ActiveModel::Serializers)

Использование ActiveModel::Serializers для преобразования моделей в JSON.

**Rationale**:
- Возвращаем только необходимые поля (без внутренних атрибутов Rails)
- Высокая производительность за счет ленивой сериализации
- Поддержка вложенных ассоциаций и условных полей
- Зрелая экосистема и соглашения сообщества

**Alternatives considered**:
- Jbuilder — отклонено как менее явный и медленный
- Grape Entities — отклонено как слишком специфичный для REST API-only

### Decision: Service objects для бизнес-логики

Расчёт "Общей суммы заказанного", фильтрация статусов и конвертация валют выносятся в service objects.

**Rationale**:
- Разделение ответственности: модели = данные, сервисы = логика
- Тестируемость: сервисы тестируются изолированно
- Переиспользование: один сервис может использоваться в разных контроллерах
- Поддержка сложной бизнес-логики (FR-010, FR-013) без засорения контроллеров

**Alternatives considered**:
- Контроллеры с fat models — отклонено как нарушение SRP
- Concerns — отклонено как менее явный паттерн для бизнес-логики

### Decision: Database seeding с FactoryBot

Использование FactoryBot для генерации тестовых данных в seeds.rb и тестах.

**Rationale**:
- Единый источник правды для тестовых данных
- Переиспользование между тестами и development окружением
- Гибкость для создания вариативных данных (мультивалютность, различные статусы)
- Автоматическая загрузка в отдельном контейнере для быстрого старта

**Alternatives considered**:
- Фикстуры (fixtures) — отклонено как менее гибкие
- Ручной seeding — отклонено как не масштабируемый

## 3. Фронтенд: React SPA

### Decision: Hooks API с TypeScript

Использование функциональных компонентов с hooks и TypeScript для типобезопасности.

**Rationale**:
- TypeScript предотвращает типовые ошибки при работе с API
- Hooks упрощают переиспользование логики (useInfiniteScroll, custom data fetchers)
- Современные практики React, рекомендуемые сообществом
- Упрощает автокомплит IDE для API контрактов

**Alternatives considered**:
- Class components — отклонено как legacy подход
- JavaScript без типов — отклонено из соображений безопасности

### Decision: Infinite scroll для списков заказов

Реализация ленивой подгрузки через Intersection Observer API в кастомном хуке.

**Rationale**:
- FR-009 требует бесконечную ленту для больших историй
- Intersection Observer — нативный, производительный способ
- Кастомный хук инкапсулирует логику и переиспользуется
- Соответствует современным UX паттернам

**Alternatives considered**:
- Пагинация — отклонена в спецификации в пользу бесконечной ленты
- Virtual scrolling — отклонен как преждевременная оптимизация

### Decision: Централизованный API service слой

Все сетевые вызовы к бэкенду инкапсулированы в отдельных service файлах (ordersService, dashboardService).

**Rationale**:
- Конституция требует инкапсуляцию API вызовов
- Централизованная обработка ошибок и авторизации
- Легче менять backend endpoints без правки компонентов
- Повторное использование fetch логики

**Alternatives considered**:
- Fetch напрямую в компонентах — отклонено как нарушение инкапсуляции
- React Query / SWR — может быть добавлено позже при необходимости кэширования

## 4. Стиль и доступность

### Decision: CSS-in-JS с поддержкой prefers-reduced-motion

Использование styled-components или CSS modules с медиа-запросом prefers-reduced-motion.

**Rationale**:
- Glass-morphism и анимации требуют точного контроля стилей
- Prefers-reduced-motion соответствует конституции: "предпочитаемое уменьшение движения"
- CSS-in-JS упрощает динамические стили и темизацию

**Alternatives considered**:
- Plain CSS — отклонено как менее гибкий
- Tailwind CSS — может быть добавлен позже, сейчас не критичен

### Decision: Легко-зелёная цветовая палитра с WCAG AA контрастом

Использование мягких светло-зелёных оттенков с проверкой контрастности.

**Rationale**:
- Требование фирменного стиля
- WCAG AA гарантирует читаемость для всех пользователей
- Конституция требует доступность без компромиссов

**Alternatives considered**:
- Отсутствие проверки контраста — отклонено как нарушение доступности

## 5. Тестирование

### Decision: RSpec для backend, Jest + React Testing Library для frontend

Многоуровневое тестирование: unit, integration, E2E.

**Rationale**:
- Конституция требует автотесты на всех уровнях
- RSpec — стандарт для Rails сообщества
- React Testing Library фокусируется на пользовательских взаимодействиях, не реализации
- FactoryBot для генерации тестовых данных

**Alternatives considered**:
- Minitest вместо RSpec — отклонено как менее популярный в сообществе
- Enzyme для тестирования React — отклонен в пользу RTL

### Decision: Playwright для E2E тестирования

Сквозные тесты пользовательских сценариев в отдельном Docker контейнере.

**Rationale**:
- Конституция требует E2E/UI тесты
- Playwright поддерживает multi-browser и более стабилен чем Cypress
- Отдельный контейнер для тестов соответствует "автотесты в Docker"
- Оценка производительности (SC-001, SC-002) через метрики Playwright

**Alternatives considered**:
- Cypress — альтернатива, менее гибкая для multi-browser
- Selenium — отклонен как устаревший

### Decision: Селективное тестирование изменённых компонентов

При изменениях запускать только релевантные тесты.

**Rationale**:
- Конституция требует запуск селективных тестов при изменениях
- Ускорение CI/CD feedback loop
- Git diff может определить затронутые файлы и их тесты

**Alternatives considered**:
- Всегда запускать все тесты — отклонено как медленно

## 6. Специфические бизнес-требования

### Decision: Хранить исторические цены и курсы валют

В OrderItem сохраняем цену на момент покупки, в Order — валюта и курс.

**Rationale**:
- FR-005 требует "цена на момент покупки"
- FR-002 требует конвертацию по историческому курсу
- Избегаем проблем при изменении цен и курсов
- Нарушение нормализации оправдано требованиями бизнеса

**Alternatives considered**:
- Ссылаться на Product.price — отклонено, цены меняются
- Хранить только в валюте заказа — отклонено для мультивалютности

### Decision: Исключение заказа целиком при частичном возврате

FR-013: если был частичный возврат, весь заказ исключается из списков и сумм.

**Rationale**:
- Уточнение в спецификации: "исключать заказ целиком"
- Упрощает бизнес-логику vs отслеживание частичных возвратов
- Меньше путаницы для пользователя

**Alternatives considered**:
- Частичные возвраты — отклонено по уточнению спецификации

### Decision: Агрегация "ранее купленных" по карточке товара

FR-011: все варианты/SKU суммируются в одну позицию.

**Rationale**:
- Требование спецификации
- Упрощает UX: пользователь видит общее количество по товару
- Агрегация выполняется в SQL (GROUP BY product_id)

**Alternatives considered**:
- Показывать каждый SKU отдельно — отклонено как нарушение FR-011

## 7. Производительность

### Decision: PostgreSQL индексы на customer_id, status, created_at

Создание индексов для оптимизации частых запросов.

**Rationale**:
- SC-001: 95% дашбордов < 2с
- SC-002: 90% открытий деталей < 30с
- Фильтрация по customer_id и status — частые паттерны
- Индексы на created_at для упорядочивания

**Alternatives considered**:
- Отсутствие индексов — отклонено, будет медленно
- Redis кэш — может быть добавлен позже если индексов недостаточно

## 8. Локализация

### Decision: React i18next для русского языка

Использование react-i18next для выноса всех UI строк в ресурсы.

**Rationale**:
- Конституция требует локализация на русском
- Все строки вынесены из компонентов
- Отсутствующие ключи = дефект (можно проверить линтером)
- Легко расширять на другие языки в будущем

**Alternatives considered**:
- Hardcoded строки — отклонено как нарушение конституции
- Простой объект переводов — может быть достаточен, но i18next более зрелый

## Заключение

Все технические решения определены, "NEEDS CLARIFICATION" отсутствуют. Архитектура соответствует конституции проекта, использует зрелые паттерны и технологии. Производительность достигается через оптимизацию запросов и индексы БД. Тестирование покрывает unit, integration и E2E уровни. Стиль и доступность соответствуют WCAG AA требованиям.

